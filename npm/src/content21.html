<p>The following example contains code demonstrating how to apply gates in Q#, using the Pauli $X$ gate as an example. It sets up a series of quantum states, and then shows the result of applying the $X$ gate to each one.</p>
<p>In the previous kata we discussed that qubit state in Q# cannot be directly assigned or accessed. The same logic is extended to quantum gates: applying a gate to a qubit modifies the internal state of that qubit, but doesn&#39;t return the resulting state of the qubit. This is why we never assign the output of these gates to any variables in this demo - they don&#39;t produce any output.</p>
<p>The same principle applies to successive qubit gates. In the mathematical notation, applying an $X$ gate followed by a $Z$ gate to a state $|\psi\rangle$ is denoted as $Z(X(|\psi\rangle))$ because the result of applying a gate to a state is another state. In Q#, applying a gate doesn&#39;t return anything, so you can&#39;t use its output as an input to another gate - something like <code>Z(X(q))</code> will not produce the expected result. Instead, to apply several gates to the same qubit, you need to call them separately in the order in which they are applied:</p>
<pre><code class="language-qsharp">X(q);
Z(q);
</code></pre>
<p>All the basic gates we will be covering in this kata are part of the <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic" target="_blank">Intrinsic</a> namespace. We&#39;re also using the function <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.diagnostics.dumpmachine" target="_blank">DumpMachine</a> to print the state of the quantum simulator.</p>
