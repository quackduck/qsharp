<p><strong>Controlled gates</strong> are a class of gates derived from other gates as follows: they act on a control qubit and a target qubit, just like the <code>CNOT</code> gate.
A controlled-<code>U</code> gate applies the <code>U</code> gate to the target qubit if the control qubit is in state $|1\rangle$, and does nothing otherwise.</p>
<p>Given a gate $U = \begin{bmatrix} \alpha &amp; \beta \\ \gamma &amp; \delta \end{bmatrix}$, its controlled version looks like this:</p>
<table>
    <tr>
        <th>Gate</th>
        <th>Matrix</th>
        <th>Q# Documentation</th>
    </tr>
    <tr>
        <td>$\text{Controlled U}$</td>
        <td>
            $$
            \begin{bmatrix}
                1 & 0 & 0 & 0 \\\ 
                0 & 1 & 0 & 0 \\\ 
                0 & 0 & \alpha & \beta \\\ 
                0 & 0 & \gamma & \delta
            \end{bmatrix}
            $$
        </td>
        <td><a href="https://docs.microsoft.com/azure/quantum/user-guide/language/expressions/functorapplication#controlled-functor" target="_blank">Controlled functor</a></td>
    </tr>
</table>

<blockquote>
<p>The CNOT gate is en example of a controlled gate, which is why it is also known as the controlled NOT or controlled <code>X</code> gate.</p>
</blockquote>
<p>The concept of controlled gates can be generalized beyond controlling single-qubit gates.
For any multi-qubit gate, its controlled version will have an identity matrix in the top left quadrant, the gate itself in the bottom right, and $0$ everywhere else.
Here, for example, is the <code>Controlled SWAP</code>, or <strong>Fredkin gate</strong>:</p>
<p>$$
\begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p>
<p>In Q#, controlled gates are applied using the <a href="https://docs.microsoft.com/azure/quantum/user-guide/language/expressions/functorapplication#controlled-functor" target="_blank"><code>Controlled</code></a> functor.
The controlled version of a gate accepts an array of control qubits (in this case an array of a single qubit), followed by the arguments to the original gate.
For example, these two lines are equivalent:</p>
<pre><code class="language-qsharp">Controlled X([control], target);
CNOT(control, target);
</code></pre>
<p>If the original gate was implemented as an operation with multiple parameters, the controlled version of this gate will take those parameters as a tuple. For example, to apply Fredkin gate, you&#39;d have to call:</p>
<pre><code class="language-qsharp">Controlled SWAP([control], (q1, q2));
</code></pre>
<p>You can use the controlled version of a Q# operation only if that operation has a controlled version defined.
The Q# compiler will often be able to generate a controlled version of the operation automatically if you put <code>is Ctl</code> after the operation&#39;s return type.
In other cases, you&#39;ll need to define the controlled version of an operation manually.</p>
