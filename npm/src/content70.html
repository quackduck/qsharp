<p>In Q# the <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.rx" target="_blank">Rx</a> gate takes the angle $\theta$ and the target qubit as inputs. To create a controlled version of this gate, we can use the <code>Controlled</code> functor.</p>
<p>A matrix representation of this operation would be:</p>
<p>$$
\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \cos\frac{\theta}{2} &amp; -i\sin\frac{\theta}{2} \\ 0 &amp; 0 &amp; -i\sin\frac{\theta}{2} &amp;  \cos\frac{\theta}{2} \end{bmatrix}
$$</p>
<p>The parameters of the new gate are changed a bit:</p>
<ul>
<li>the first parameter has to be the array of control qubits; the <strong>Rx</strong> gate will be applied to the target only if these are all in the $|1\rangle$ state. Note that this parameter has to be an array, even if there is just one control qubit!</li>
<li>The second parameter is a tuple with the parameters that you would&#39;ve passed to the original <strong>Rx</strong> gate. You can create a tuple of values by putting round brackets around them.</li>
</ul>
<blockquote>
<p>The <code>Controlled</code> functor can be used before any single qubit gate to make it a controlled gate. The first argument will be an <code>array</code> of qubits even if you are using a single control qubit, like in the <strong>CNOT</strong> gate. The second argument is a tuple <code>()</code> with the parameters of the gate. For example, these two gates are equivalent: <code>CNOT(qs[0],qs[1])</code> and <code>Controlled X([qs[0]],(qs[1]));</code></p>
</blockquote>
