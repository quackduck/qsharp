<p>In the above examples the <code>CNOT</code> gate acted on two adjacent qubits. However, multi-qubit gates can act on non-adjacent qubits as well. Let&#39;s see how to work out the math of the system state change in this case.</p>
<p>Take 3 qubits in an arbitrary state $|\psi\rangle = x_{000} |000\rangle + x_{001}|001\rangle + x_{010}|010\rangle + x_{011}|011\rangle + x_{100}|100\rangle + x_{101}|101\rangle + x_{110}|110\rangle + x_{111}|111\rangle $.</p>
<p>We can apply the <code>CNOT</code> gate on 1st and 3rd qubits, with the 1st qubit as control and the 3rd qubit as target. Let&#39;s label the 3-qubit gate that describes the effect of this on the whole system as <code>CINOT</code>. The <code>CINOT</code> ignores the 2nd qubit (leaves it unchanged) and applies the <code>CNOT</code> gate as specified above.</p>
<h2>Q#</h2>
<p>In Q# we describe the operation as the sequence of gates that are applied to the qubits, regardless of whether the qubits are adjacent or not.</p>
<pre><code class="language-qsharp">operation CINOT (qs: Qubit[]) : Unit {
    CNOT(qs[0], qs[2]); // Length of qs is assumed to be 3
}
</code></pre>
<h2>Dirac Notation</h2>
<p>In Dirac notation we can consider the effect of the gate on each basis vector separately: each basis vector $|a_1a_2a_3\rangle$ remains unchanged if $a_1 = 0$, and becomes $|a_1a_2(\neg a_3)\rangle$ if $a_1 = 1$. The full effect on the state becomes:</p>
<p>$$\text{CINOT}|\psi\rangle = x_{000} \text{CINOT}|000\rangle + x_{001} \text{CINOT}|001\rangle + x_{010} \text{CINOT}|010\rangle + x_{011} \text{CINOT}|011\rangle+$$
$$x_{100} \text{CINOT}|100\rangle + x_{101} \text{CINOT}|101\rangle + x_{110} \text{CINOT}|110\rangle + x_{111} \text{CINOT}|111\rangle =$$
$$x_{000}|000\rangle + x_{001}|001\rangle + x_{010}|010\rangle + x_{011}|011\rangle + x_{101}|100\rangle + x_{100}|101\rangle + x_{111}|110\rangle + x_{110}|111\rangle $$</p>
<h2>Matrix Form</h2>
<p>$\text{CINOT}$ can also be represented in matrix form as a $2^3 \times 2^3$ matrix:
$$
\begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix}
$$</p>
<p>Applying $\text{CINOT}$ to $|\psi\rangle$ gives us
$$
\text{CINOT} \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ 
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
    x_{000} \\ x_{001} \\ x_{010} \\ x_{011} \\ x_{100} \\ x_{101} \\ x_{110} \\ x_{111}
\end{bmatrix} =
\begin{bmatrix}
    x_{000} \\ x_{001} \\ x_{010} \\ x_{011} \\ x_{101} \\ x_{100} \\ x_{111} \\ x_{110}
\end{bmatrix}
$$</p>
<p>However, as $N$ gets larger, creating a full size matrix can be extremely unwieldy. To express the matrix without spelling out its elements, we can use the following trick:</p>
<ol>
<li>Apply the <code>SWAP</code> gate on the 1st and 2nd qubits.
This will bring the qubits on which the <code>CNOT</code> gate acts next to each other, without any extra qubits between them.</li>
<li>Apply the <code>CNOT</code> on 2nd and 3rd qubits.
Since now the gate acts on adjacent qubits, this can be represented as a tensor product of the gate we&#39;re applying and <code>I</code> gates.</li>
<li>Apply the <code>SWAP</code> gate on the 1st and 2nd qubits again.</li>
</ol>
<p>These can be represented as applying the following gates on the 3 qubits.</p>
<ol>
<li><p>$\text{SWAP} \otimes I$
$$
x_{000}|000\rangle + x_{001}|001\rangle + x_{100}|010\rangle + x_{101}|011\rangle +
x_{010}|100\rangle + x_{011}|101\rangle + x_{110}|110\rangle + x_{111}|111\rangle
$$</p>
</li>
<li><p>$I \otimes \text{CNOT}$
$$
x_{000}|000\rangle + x_{001}|001\rangle + x_{101}|010\rangle + x_{100}|011\rangle +
x_{010}|100\rangle + x_{011}|101\rangle + x_{111}|110\rangle + x_{110}|111\rangle
$$</p>
</li>
<li><p>$\text{SWAP} \otimes I$
$$
x_{000}|000\rangle + x_{001}|001\rangle + x_{010}|010\rangle + x_{011}|011\rangle +
x_{101}|100\rangle + x_{100}|101\rangle + x_{111}|110\rangle + x_{110}|111\rangle
$$</p>
</li>
</ol>
<p>The result is the the $\text{CINOT}$ gate as we intended; so we can write</p>
<p>$$\text{CINOT} = (\text{SWAP} \otimes I)(I \otimes \text{CNOT})(\text{SWAP} \otimes I)$$</p>
<blockquote>
<p>Note that in matrix notation we always apply a gate to the complete system, so we must apply $\text{SWAP} \otimes I$, spelling the identity gate explicitly.
However, when implementing the unitary $\text{SWAP} \otimes I$ in Q#, we need only to call <code>SWAP(qs[0], qs[1])</code> - the remaining qubit <code>qs[2]</code> will not change, which is equivalent to applying an implicit identity gate.</p>
<p>We can also spell out all gates applied explicitly (this makes for a much longer code, though):</p>
<pre><code class="language-qsharp">operation CINOT (qs: Qubit[]) : Unit {
    // First step
    SWAP(qs[0], qs[1]);
    I(qs[2]);
    // Second step
    I(qs[0]);
    CNOT(qs[1], qs[2]);
    // Third step
    SWAP(qs[0], qs[1]);
    I(qs[2]);
}
</code></pre>
</blockquote>
