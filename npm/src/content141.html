<p>A marking oracle $U_{mark}$ is an oracle that encodes the value of the classical function $f$ it implements in the <em>amplitude</em> of the qubit state. When provided an input array of qubits in the basis state $|\vec{x}\rangle$ and an output qubit in the basis state $|y\rangle$, it flips the state of the output qubit if $f(x)=1$. (You can also represent this as addition modulo 2 between $f(x)$ and $y$.)  Hence $U_{mark}$ is an operator that performs the following operation:</p>
<p>$$U_{mark}|\vec{x}\rangle |y\rangle = U_{mark}\big(|\vec{x}\rangle \otimes |y\rangle\big) = |\vec{x}\rangle \otimes |y \oplus f(x)\rangle$$</p>
<p>Again, since all quantum operations are linear, you can figure out the effect of this operation on superposition state knowing its effect on the basis states using its linearity. </p>
<p>A marking oracle has distinct &quot;input&quot; and &quot;output&quot; qubits, but in general the effect of the oracle application is the change in the state of the whole system rather than of the &quot;output&quot; qubits only. We will look at this closer in a moment.</p>
<h2>Marking Oracle for Alternating Bit Pattern Function</h2>
<p>Consider the function $f(x)$ that takes $3$ bits of input and returns $1$ if $x=101$ or $x=010$, and $0$ otherwise (it is the same function we&#39;ve seen in the demo &quot;Phase oracle for alternating bit pattern function&quot;).</p>
<p>The marking oracle that implements this function will take an array of 3 qubits as an &quot;input&quot; register and an &quot;output&quot; qubit, and will flip the state of the output qubit if the input qubit was in basis state $|101\rangle$ or $|010\rangle$, and do nothing otherwise. Let&#39;s see the effect of this oracle on a superposition state.</p>
